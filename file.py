import sys def chess_to_coords(chess_notation): letter = ord(chess_notation[0]) - ord('A') number = int(chess_notation[1:]) - 1 return (number, letter) def coords_to_chess(coords): letter = chr(coords[1] + ord('A')) number = coords[0] + 1 return f"{letter}{number}" def knight_moves(start, end): start_coords = chess_to_coords(start) end_coords = chess_to_coords(end) moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)] queue = [(start_coords, [start_coords])] visited = set([start_coords]) while queue: current, path = queue.pop(0) if current == end_coords: return [coords_to_chess(coord) for coord in path] for move in moves: next_coords = (current[0] + move[0], current[1] + move[1]) if 0 <= next_coords[0] < 26 and 0 <= next_coords[1] < 26 and next_coords not in visited: queue.append((next_coords, path + [next_coords])) visited.add(next_coords) return None if __name__ == "__main__": start = sys.argv[1] end = sys.argv[2] path = knight_moves(start, end) if path: print(path) else: print("Пути от", start, "до", end, "не существует.")
